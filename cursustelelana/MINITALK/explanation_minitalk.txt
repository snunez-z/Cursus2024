MINI TALK

1.- OBJETIVO DEL PROYECTO Y RETOS QUE PLANTEA 
Programa de comunicacion entre un cliente y un server, el que van a intercambiar datos usando UNIX.
UNIX es un sistema operativo multiusuario y multiproceso. Ofrece facilidades para programar, y un ambiente propio para las tareas de diseño de software 
con una gran cantidad de ayuda y utilerías.
Lo mas importante de este proyecto es entender que se comunican a traves de un protocolo, tiene que estar de acuerdo en el lenguaje, 
en como van a recibir las señales y en el significado de las señales.

1.- RETO : TIEMPO DE EJECUCION
Teniendo en cuenta las herramientas que nos dan (funciones permitidas), nos encontramos con el primer reto. Tiempo de ejecucion entre un mensaje y otro posible mensaje.
Aunque el mensaje se reciben y se procesan en microsegundos, si un cliente enviase por ejemplo 1000 señales distintos seguidos, sin pausa. al server no le daria tiempo a procesarlos todos. 
Una forma de arreglarlo en poniendo un tiempo de espera, pero esto tiene dos pegas:
1.- que no es eficiente porque en algunos casos se desperdicia el tiempo porque el server esta esperando sin hacer nada.
2.- En otros casos será insuficente porque no en todas las maquinas irá a la misma velocidad..
La mejor solución es hacer un protocolo entre server y cliente, que hablen entre los dos y el cliente no enviara la siguiente señal, haya que el server no lo haya recibido y procesado.
El server le va a avisar enviandole una señal al cliente. 

Para enviar un mensaje necesitamos enviar la señal y enviar el mensaje. Con las herramientas que tenemos solo podemos enviar la señal, el comando kill solo envia señal, no informacion.
No se nos permite usar la funcion sigqueue que no dejaria enviar int (4 bytes) que es mas que un char por lo tanto nos daria de sobra para enviar caracter a caracter el mensaje.
Pero nos permiten enviar dos señales distintas SIGUSR1 Y LA SIGUSR2. Es ahora cuando se ponen de acuerdo en que significa cada una de ellas.
SIGUSR1 será =0 y SIGUSR2 puede ser = 1 o viceversa. Con la conversion a binarios de cuaquier numero (teniendo en cuenta que en C todos son numeros, ASCII), cada señal implica un bit 
que será un 1 o un 0 dependiendo de si es SIGUSR1 o SIGUSR2, porque asi lo han decidido ellos.Como un lenguaje codificado o uno de signos.

2.-RETO - CODIFICACION 

El cliente tiene que codificar el mensaje paa que el server lo reciba.
Como en programacion todo son numeros, usamos las señales y el sistema binario con operaciones logicas para codificar el mensaje.

3.- RETO - DESCODIFICACION 

El server lo recibe y tiene que descodificarlo para mostrarlo por pantalla.

------------------------------------------------------------------------------------------------------------------------------------
2.-  CONCEPTOS Y FUNCIONES
La comunicacion entre servidor y cliente se hará mediante un PID.
PID = Un dato identificativo de los procesos que un programa hace.
Solo se puede usar una variable global por programa. Una variable global es una variable que pueden usar todoas las funcioens que esten dentro del punto c

Son 2 programas. Uno es el cliente que envia un mensaje y otro es el server que se queda a la espera de recibirlo.
El problema es que no sabe cuando va a recibir el mensaje y cuanto tiene que esperar.
El server se queda tranquilo , a la espera, sin hacer nada, sin consumir recursos porque cuando le llegue algo le van a despertar con una señal.
Por lo tanto el server tiene una parte sincrona ( se ejecuta en orden, linea tras linea) y otra asincrona, que se ejectura cuando sea llamada, el server no sabe cuando se va a ejecutar.

Nuestra aplicación consta de dos procesos, uno que espera leer cada carácter (el servidor) y el otro que enviará el carácter al servidor (el cliente). 
La cuestión clave es que el segundo proceso deberá señalar de alguna manera al primero cada nuevo personaje encontrado.

Un proceso puede enviar una señal con la llamada kill o risesystem.

3.- SEÑALES - SIGNALS

Las señales son interrupciones de software que se utilizan para interrumpir un proceso en ejecución y ejecutar otra acción.
Estas interrupciones se encuentran a menudo en diversas situaciones, como errores de bus o fallas de segmento, 
y al intentar finalizar un programa con el comando ctrl+c.

Cuando se activa una señal, el proceso envía una señal al kernel que luego utiliza la función sig_handler() para realizar una de tres acciones posibles: 
ignorar, capturar o predeterminar.


Un proceso es un programa en ejecución que, por lo general, no desaparece hasta que dicho programa finaliza su cometido o es detenido. 
Cualquier programa que esté en ejecución tiene cómo mínimo un proceso activo
Un proceso puede estar en varios estados:

    *En ejecución en modo usuario.
    *En ejecución en modo núcleo.
    *En espera.
    *Dormido.
    *Listo para ser ejecutado(pero sin ejecutarse aún).
    *Dormido en el swap.
    *Zombie(finalizando).

Cada proceso posee varios datos identificativos que ayudan mucho a una administrador a la hora de realizar cualquier tipo de control y/o gestión. 
El número de proceso, denominado cómo PID (Process ID): Este número es un número único no repetible. 
El primer proceso es el PID 1, y va aumentando progresivamente a medida que van generándose nuevos procesos. 
En caso de que un programa fuese ejecutado varias veces, cada ejecución tendría un PID correspondiente.


4.- FUNCIONES

libreria signal.h 

malloc	    Solicitar un bloque de memoria del tamaño suministrado como parámetro.
free	    Desasigna un bloque de memoria que se había asignado previamente mediante una llamada.
write	    Hace que los bytes que indiques del buffer sean escritos en el file descriptor seleccionado.
signal	    permite controlar el comportamento de tu programa en funcion de las señales que recibe.
getpid	    Se utiliza para obtener el ID de proceso (PID)
kill	    Envia señales a procesos específicos, permitiendo controlar y comunicarse con ellos
usleep	    Suspende la ejecución de un programa por un período de tiempo expresado en microsegundos.
exit	    Finaliza inmediatamente el programa liberando la memoria dinamica asignada
sigemptyset crea un conjunto de señales vacio, lo que significa que ninguna señal está incluida en ese conjunto. 
            Esto es útil cuando se quiere inicializar un conjunto de señales antes de agregar señales específicas a él utilizando funciones como sigaddset.
sigaddset   La función sigaddset se utiliza para agregar una señal específica a un conjunto de señales en C. Estos conjuntos de señales son como listas especiales que indican a un programa qué señales debe "escuchar" o estar atento.
sigaction   La función sigaction se utiliza para establecer la acción que se tomará cuando una señal específica llegue a tu programa. 
            Esta acción podría ser ignorar la señal, ejecutar una función específica (manejador de señal), o restaurar el comportamiento predeterminado para esa señal.

pause       Suspende la ejecucion de un programa hasta que llegue la señal.
sleep       Suspende la ejecucion del programa durante x segundos que se el debe especificar.

5.COMO FUNCIONA

Para compilar el programa seguimos los siguientes pasos:

git clone https://github.com/gjmacias/minitalk
cd minitalk
make
Luego ejecutamos en una terminal el server:

./server
Este te dará el PID para comunicarse con los clientes:

SUCCESS!, Server is ready :D! The PID: *VWXYZ*
Luego ejecutamos desde OTRA terminal el client y le añadimos los parametros de PID y los parametros a pasar:

./client *VWXYZ* "soy un comentario que voy a pasar del cliente al servidor" 

./server soy un comentario que voy a pasar del cliente al servidor
