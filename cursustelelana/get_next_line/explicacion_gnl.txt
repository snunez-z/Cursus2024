
Get_next_line  es una función (que se puede usar en un programa), que lee la siguiente línea de un fichero previamente abierto (es decir, get_next_line no abre el fichero, sino que se lo pasan abierto ya), guarda dicha línea en un buffer reservado con malloc y retorna dicho buffer. Dado que el buffer se reserva con malloc y se retorna (es decir, no lo libera la propia función), es responsabilidad de quien llame a esta función liberar (free) dicho buffer cuando ya no sea necesario.

El contrato de la función es el siguiente:
* Recibe el file descriptor de donde tiene que leer
* Retorna el puntero a la direccion de memoria donde esta el buffer.
Condicines generales :
	* Si hay un error al leer del fichero, retorna NULL
	* Si no hay nada que leer del fichero, retorna NULL
	* En caso contrario, retorna el contenido del fichero desde su posición actual hasta encontrar un salto de línea (\n) o el final del fichero.
	* Si se encuentra el salto de línea (\n) dicho carácter será también incluído en el buffer retornado

Para localizar el final de línea, debemos leer del carácter a carácter hasta que, efectivamente,
demos con el \n (o con el final del fichero). Sin embargo, ir al disco cada vez para leer sólo un carácter
es poco óptimo (leer del disco es una operación lenta), sin embargo leer de memoria es mucho más rápido.
Para optimizar el proceso, lo que haremos será crear una función que retorne el siguiente carácter del
fichero (la he llamado "read_one_char") pero dicha función, en lugar de leer carácter a carácter del fichero,
en realidad leerá un bloque, concreatamente leeremos tantos caracteres como nos indique la constante BUFFER_SIZE
(que se provee cuando se compila la función) y, a partir de ese momento, irá retornando un carácter de dicho bloque,
uno cada vez. Para poder hacer esto, las llamadas a la función read_one_char tienen que recordar cuántos
caracteres se han leído del disco (el máximo será, por supuesto, BUFFER_SIZE), qué carácter es el siguiente
que tendremos que retornar y el propio bloque en sí (donde están todos los caracteres leídos en bloque).
Dado que la función tiene que "recordar" valores entre llamadas, dichos datos deberán ser variables estáticas.

Para hacer esta lectura usamos dentro de la funcion principal "get_next_line.c" una funcion estatica "read_one_char) para leer un char.

Dentro del "Get_next_line" llamaremos  a esta funcion y a otras 5 mas.

Una vez optimizado el proceso de lectura del fichero, tenemos otro problema:
No sabemos el tamaño del buffer que vamos a necesitar para leer todos los caracteres de la línea actual. Podemos
tener líneas muy cortas (o incluso vacías, sólo con el \n) o líneas muy largas. Existe la opción de reservar un
buffer enorme, pero desperdiciaremos mucha memoria en muchos casos (y aún así podemos quedarnos cortos en casos
extremos) o crear una estructura de datos para crear un buffer inicial e ir haciéndolo crecer si, a base de añadir
caracteres, se queda corto. He optado por esta segunda solución.

Para poder tener un buffer que crezca si se queda corto, necesito una estructura de datos con los siguientes datos:
* buffer: el propio buffer en sí, reservado con malloc. Siempre reservaré un byte extra para el \0
* buffer_size: cuantos caracteres COMO MAXIMO caben en el buffer (sin contar con el \0 final)
* str_len: cuantos caracteres llevo ocupados del buffer. de este modo, si str_len alcanza a buffer_size, sabré que
           antes de añadir un carácter más, tendré que agrandar el buffer
Para sustentar esta estructura, he creado unas funciones que son:
* La de inicialización (o creación): dstr_create, que reserva espacio para la estructura y reserva el buffer inicial
* La de destrucción (o cierre): dstr_destroy, que libera tanto el buffer como la estructura en si
* dstr_append_char: la que me permite añadir un carácter al buffer y, si es necesario, agrandarlo previamente
* dstr_truncate: una vez he añadido todos los caracteres hasta llegar al \n (o al final del fichero), lo que hago es
                 reservar un bloque de memoria con los caracteres que realmente necesito (ni más ni menos), copiar
                 el contenido del buffer grande y liberarlo (ya que no hace falta más porque se ha copiado al
                 espacio pequeño). Eso hace esta función
* copy_buffer: cuando necesito agrandar el buffer o cuando creo el pequeño con el tamaño exacto necesario (ver
               dstr_truncate) tengo que copiar el contenido del antiguo buffer al nuevo. Eso hace esta función


1.- GET_NEXT_LINE.C (Recibe el fd y retorna el puntero a un string)

	Voy a llamar a read_one_char para leer asi que necesito una variable de tipo int donde recoger lo que retorne
    que me va a indicar si la lectura ha ido bien, ha ocurrido un error o se ha llegado al final del fichero.
	Lo que leo es un char, asi que tengo que declararme una variable de tipo char
	Voy a leer linea a linea asi que me declaro la linea de tipo structura t_dstr para poder almacenar tantos
    caracteres como necesite

	Pasos  
	1.1 Leo un char de un file descriptor si esta vacio o falla la lectura retorno  NULL
	1.2 Reservo memoria para la linea llamando a la funcion dstr_create.
		Si la memoria falla retorna NULL y se sale.
	1.3 Mientras el resultado de la lectura sea positivo entra en el bucle:
		.- En la variable line se guarda el resultado de añadir el char llamando a dstr_append_char pasandole los argumentos de linea y de ch.Lo agrandará si es necesario.
		.- Si falla el agrandamiento  de memoria, se retorna NULL y sale.
		.- Si llega al salto de linea, o sea ha acabado la linea, se retorna el resultado con la reduccion de memoria hecha llamando a dstr_reduce.La funcion dstr_reduce, se encarga de la prteccion de fallo de memoria.
		.- Si todo ha ido bien, se vuelve a leer llamando de nuevo a la funcion read_one_char.
		Se saldra del bucle cuando falle o cuando no haya mas que leer.
	1.4 Si no hay nada que leer se retorna el resultado de llamar a dstr_destry (line) que libera toda la memoria usada, tanto del buffer como de la estructura.
	1.5 Retorno lo leido hasta ese momento con la reduccion de memoria ajustada llamando a la funcion dstr_reduce (line).

2.- READ_ONE_CHAR (Recibe el fd y un char  * destino y retorna un int = 1 si ha leido)

Se declara :
	Un buffer de tipo char * cuya memoria sera la del tamaño del BUFFER_SIZE que me pasen.
	un int buffer_size y un int buffer_index que van a ayudarme en la lectura .

	Pasos 

	2.1 Para inicializar la primera lectura equiparo el el tamaño del buffer a la posicion que al estar inicializados a cero ambos me permiten usarlos como condicion y hacer la primera lectura.
    	Si e buffer_size >= buffer_index, buffer_size = la primera lectura del file descriptr, metiendolo en el buffer  y del tamaño que me pasen en BUFFER_SIZE.
    	Si falla la lectura se retorna 1-1, Si esta vacio se retorna 0.
		Buffer_index = 0; porque se vuelve a coocar en la suiguiente linea en la posicion cero dodne va a empezar a leer de nuevo.
	2.2 Ahora ya en el buffer de destino guardará en la posicion que se encuentre el carcater que vaya leyendo.
	2.3 Index itera.
	2.4	Retorna 1 indicando que ha leido un caracter.

	3.- DSTR_APPEND_CHAR (recibe el buffer de destino de tipo struct y el char a añadir y retorna el puntero a la estructura).

	3.1 Comprobar si el tamaño  de lo leido es mayor o igual que el buffer reservado.
    	Eso  se sabe si el el tamaño de lo leido(str_len) >= que el buffer_size 
		en ese caso hay que agrandar el buffer y para ello .
	3.1.1 Declalar un char  * new_buffer. 
		  Rreservar memoria para el actual buffer_size + Malloc size + 1 (\0)
		  Si falla se llama a dstr_destroy para liberr la memoria y se retorna NULL.
		  Si no falla se llama a copy_buffer para copiar el buffer antiguo, en el nuevo con el tamaño del buffer_size + 1.
		  Libera el antiguo buffer
		  El buffer ahora es igual al nuevo buffer
		  Y el buffer_size = buffer size que habia + malloc size (la nueva medida que se le da de reserva)
	3.2 Ahora que el tamaño ya se ha agrandado
		Buffer en la posicion libre que tenga str_len = ch, al carcater nuevo que se vaya a copiar
		Buffer en la psocion libre que tenga str_len + 1 se pondra el barra cero
		str_len sumara 1
	3.3 (Retorna destino)

4.- DSTR_CREATE (No recibe nada y retorna puntero a donde reserva memoria )

	Pasos 

	4.1 Se  declara un puntero de tipo struct
	4.2 Se hace la reserva de la structura y si falla se retorna NULL.
	4.3 Si no falla, se hace la reserva del buffer  medida de MALLOC_SIZE + 1
    	Si falla esta reserva se libera la anterior y se retorna NULL
	4.4 Se  pone en la osicion del buffer 0 el \0 para  asegurar que acaba bien.
	4.5 buffer_size sera igual a MALLOC_SIZE
	4.6 Str_len será igual a \0 para indicar que es uan cadena vacia y el \0 es un carcater no imprimible.
	4.7 Se retorna el puntero de tipo struct.

5.- DSTR_DESTROY ( recibe el untero a la struct a liberar y retorna el puntero a la string.
	5.1 Libera primero el buffer y luego la struct. Retorna NULL para  reducir el espacio del GET_NEXT_LINE.

6.- DSTR_REDUCE ( recibe el struct puntero y retorna el char * )

El caso  especial seria si coincidese que el tamaño de lo leido y el buffer reservado coincidiesen. no seria muy habitual pero hay que contemplarlo asi que empemos contemplando que pasaria en ese caso.
Nos declaramos una variable de tipo char * y la llamamos, reduced_buffer.
	6.1 SSabemos que si str_len = a buuffer_size son iguales y en ese caso hacemos los iguiente:
		Reduced_buffer = buffer actual
		Liberamos la estructura, el buffer no porque me sirve al ser igual 
		Retorno el buffer reducido que coincide con el que tenia.
		Reservo memoria para el reduced_buffer que sera el str_len + 1 * sizeof de char
	6.2	Si falla llamamos a str_destroy para liberar la reserva y se retorna NULL
	6.3	Si no falla llamamos a cpy_buffer para copiar el buffer antiguo, en el reducido psandole str_len + 1 como medida.
	6.4 Se llama a str_destroy para liberar todo, la estriictura y el buffer antiguo
	6.5	Se retorna el buffer reducido.

 7.- COPY_BUFFER (recibe la fuente, el destino y un size_t con los caracteres a copiar y no retora nada)

 	7.1 Se  declara un index de tipo size_t
	7.2 Bucle mientras index que se inicializa en cero sea mas grande.
 	7.3	En la posiciónn que este en destino se copiará lo que hay en la fuente en la misma posicion.
 	7.4 Index ++; 

8.- MAIN	

 Vamos a leer de un fd linea a linea.
 	Pasos
 	8.1  Declaramos un int fd
 	8.2  Declaramos un char * line
 	8.3	if argc > 2  - printf error y retornar - 1
 	8.4 Se abre el arhivo de lectura
 	8.5 Se llama a la funcion get_next_line y se recge en line.
 	8.6 Mientras line no falle se mete en el bucle
 		Printea line
 		Libera line
 		y vuelve a llamar a get_next__line
 		Sale del bucle 
 	8.7 Cierra fichero
 	8.8 Retorna (0);


BONUS

La funcion se trata de leer un archivo linea a linea, pero si desde el main, se abriesen mas archivos, leeria de forma aleatoria. 
Es necesario registrar nuevos file descriptors, no solo añadir nuevos sino que ver si hay mas de uno, si ya hay otros file descriptors.
Para localizarnos necesitamos un dato que identifique el file descriptor para poder buscarlos, lo que reporta open de un fd es distinto de los que retorna open de otro fd. 
Ese dato hay que incoporarlo dentro de la estructura t_gnl_bonus para poder usarlo para buscar y leer de forma ordenada de cada file descriptor. pRa ir desde el primer file descriptor hasta el ultimo que hay, de forma consecutiva ir buscandolo. 
Ese dato hay que añadirlo a la estructura para tener el dato que cuando venga Read_one_char y nos diga que nos estan pidiendo que lea un caracter del fd x si no esta incluido dentro de cada posicion de la estructura no vamos a ser capaces de inicializar el tamaño, la posicion y el buffer de ese file descriptor en concreto. Se deja anotsdo y asi la segunda vez que nos pidan otra linea, saber en que posicion del array está.
Asi se evita mezclar las lineas de uno y de otro archivo. 

Para la busqueda de ese file descriptor, tenemos la funcion "Search_fd"

1.- Funcion SEARCH-FD

Como solo podemos usar una estatica, hemos metido tanto el array buffer donde se van a ir metiendo la lectura de cada fd y el resto de datos del struct que se necesitan tener en cuenta para la lectura de cada fd. El tamaño, la posicion, el buffer de ese fd y el fd al que pertenece.Lo suyo seria tener dos estaticas, una para el buffer y otra para la estructura pero como solo nos permiten una estatica, se ha solucionado de esta forma.

* struct t_open_files (buffer y el fd_num)
* struct t_gnl_bonus (buffer, buffer_size, buffer_index y el fd)

Search_fd va a ser llamado por read_one_char, va a necesitar que search_fd le de el tamaño y la posicion espècifico de ese fd, con lo que devuelva "search_fd" hara lo mismo que hacia en el caso de la parte obligatoria, leer un caracterr de ese fd.

Como funciona , que hace, como busca? 

Recorre el array (fd_to_open.fd_num) con un bucle: Desde la posicion  (Index = 0) hasta la ultima que indique (fd_num).
1.- Condicion = Mientras la posicion sea menor que ese fd_num de la variable fd_to_open va a entrar en el bucle. 
    .- Por cada posicion del array como tenemos que retornar el puntero me voy a coger el puntero a lo que hay en cada posicion.
	de ahí, que la variable de tipo t_gnl_bonus one_file_data va a indicar donde esta, la direccion de memoria el indice index del array buffer que esta dentro de fd_to_open.
	.- Ahora tenego que contrastar el dato que me dan con el fd que me pasan, de ahi la condicion de si los datos del campo fd (one_file_data) son iguales al fd que te pasan, lo has encontrado y por lo tanto hay que retornar donde esta, el puntero a one:-file_data.
2.- Itera la posicion, siguiente posicion.
3.- Si se sale es que no lo ha encontrado, o sea que el fd que nso piden es nuevo, aun no ha ledio nada de ese fd.
    que tenemos  que hacer? Ocupar una posicion nueva y para eso nos sirve la variable fd_num.
4.- La nueva posicion va a ser la siguiente libre (fd_to_open.fd_num).
5.- Buffer_size y el buffer_index se inicializan a cero.
6.- Inicizializamos el campo fd de one_file_data al fd 
7.- Como hemos ocupado una nueva psocion del array fd_num tiene que iterar al siguiente.
8.- Retornamos el puntero a la posicion que acabamos de inicializar.
